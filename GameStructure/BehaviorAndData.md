# 行为和数据

## 作为行为和数据的游戏

“游戏是什么”是个颇难回答的问题，但限定于计算机的视角，我们可以给电子游戏一个大致的描述——游戏就是主要用于娱乐的交互性程序。

而一个程序一般来说包括行为和数据两个部分。举例来说，游戏中各种人物属性是数据，而按照设定规则计算战斗伤害和游戏胜负的过程是行为，计算出来的伤害数值和胜负结果则又是数据。这种行为和数据的二分其实不仅仅对电子游戏起效，对大多数的桌游或其他游戏也是如此。例如卡牌游戏的卡牌牌面是数据，而出牌是行为；围棋的棋局状态是数据，而落子是行为。

> 这里关于“行为”和“数据”的描述当然是不够严谨准确的，只是提供一个大概的印象。

一款游戏在计算机视角下，其实就是由行为和数据构成的一个程序。复制了它的行为和数据，也就复制了这款游戏。所以，要让一款游戏不朽，本质上就是让它的行为和数据不朽。

## 游戏不能运行的本质

要让一款游戏的行为和数据“不朽”其实说简单也简单。游戏的行为和数据在计算机中分别保存为行为文件（或者叫可执行文件）和数据文件。只要妥善保存这些文件，就能让游戏一直存在。问题在于数据文件保存久了仍旧是数据，但行为文件保存久了不一定还能执行。

所谓的行为文件，其实也是一种数据文件。只不过其中保存的不是图像的像素数值，也不是游戏人物的血量，而是计算机动作的序列。例如说你想让伤害值经过护甲衰减作用到敌方的血量上，这本身是一个计算行为。这个行为需要计算机先用伤害减去护甲，然后再用血量减去上一步所得的差。而行为文件就是对这个过程中先做什么和后做什么的描述，好像剧本指挥演员一样指挥计算机进行计算行为。

问题在于，行为文件不像数据文件一样可以从零开始凭空定义。一个行为文件只能是已有的基本动作（例如加减乘除）的组合排列，而没法凭空创造新的基本动作。而另一方面，不同的计算机软硬件系统又会提供不同的基本动作。所以，写给不同计算机系统的行为文件也会有所不同——即便它们最终的执行效果都差不多。

如果一款游戏没有针对某一个计算机软硬件平台编写专门的行为文件，那么它就是无法在这个平台上运行。这就是 Windows 游戏不能在 iOS 上运行或者老游戏没法在新系统上运行的根本原因。只有游戏开发者或者别的什么人为不同的平台都编写了执行效果一样（对玩家来说）的行为文件，一款游戏才能在不同平台上运行。这有点类似于把原本的汉语剧本翻译成英语再让只懂英语的演员去演。这种翻译说起来简单，但实际上工作量巨大，而且由于计算机软硬件总在不断更新迭代，当新的软硬件平台出现时就需要为新的平台再做一次翻译。

所以要让一款游戏总保持可运行，就需要及时让它的运行文件有适应于新平台的版本或者想办法让旧的执行文件能在新平台上执行。

## 行为的数据化

既然对行为文件的翻新工作是不可避免的。那么有没有什么办法让这种翻新工作尽可能少或者尽可能好做呢？还真有，这就是行为文件的数据化。

这一点又可以分两种情况。第一种情况是通过设计让行为中的数据分离出来。例如游戏中的剧情对话。如果你把“说‘你好’”理解为一个动作，那么它就需要写在行为文件中。但如果你把“说”理解为动作，说的内容“你好”理解为行为，那么就仅仅需要把“说”这个动作写在行为文件中，说的内容“你好”就可以写在数据文件中。这样就能让游戏中的对话文本和行为文件分离，不仅减小了行为文件的体积，而且方便了以后做一些文本修改或者翻译工作。

第二种情况是使用虚拟机把行为和真实的软硬件平台隔离开。这里的虚拟机负责把行为文件翻译给真实的软硬件平台去执行。如果要类比戏剧的化，就像是给剧本配备了一个多语言的专职翻译。这样在操不同方言的演员团体排演剧本的时候，由虚拟机这个翻译把剧本翻译给他们听，不需要剧本作家本人一遍遍用不同语言重写剧本。这种情况下，虚拟机负责行为，而原本的行为文件成了虚拟机的数据文件。

此外，以上两种方法还可以同时采用。

## 现状

虽说方法已经摆出来了。但是具体要做还是要付出很多代价的。不仅行为数据化本身需要设计者投入更多的精力去精心设计。而且充当翻译媒介的虚拟机本身也还是需要维护的。此外，一些行为数据化方法还可能带来比较明显的计算效率的损失。因此，现实当中的游戏并不都具有很高的行为数据化程度。但确实有很多游戏在推进行为数据化，并且取得了不错的实践效果。
